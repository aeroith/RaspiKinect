#pragma once

#include <pcl/common/transforms.h>
#include <pcl/filters/filter.h>
#include <pcl/filters/median_filter.h>
#include <pcl/filters/passthrough.h>
#include <pcl/filters/radius_outlier_removal.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/surface/mls.h>
#include <pcl/filters/fast_bilateral.h>
/**
* A filter class which holds many useful filters
*/
class Filter {
public:

/**
* Remove NaN values generated by pcl algorithms.
* @param[in] points input point cloud
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    removeNaNPoints(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud);
/**
* Apply passthrough filter to get rid of unnecessary Z values. (background removal)
* Even background removal is not necessary, apply the min and max values as zero
* to remove blank points generated from libfreenect drivers.
* @param[in] cloud input point cloud
* @param[in] min_val minimum value to apply the filter
* @param[in] max_val maximum value to apply the filter
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    passThrough(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud,
                float min_val, float max_val);

/**
* Apply Voxel Grid filter to downsample data without losing necessary information
* @param[in] cloud input point cloud
* @param[in] leaf_size the size of leaf
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    voxelGrid(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud,
              float leaf_size);

/**
* remove noisy measurements, e.g. outliers, from a point cloud dataset using
* statistical analysis techniques.
* @param[in] cloud input point cloud
* @param[in] mean the number of neighbors to analyze for each point 
* @param[in] std_dev the standard deviation multiplier
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    statisticalOutlierRemoval(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &input,
                              float mean, float std_dev);

/**
The user specifies a number of neighbors which every indice must have within a
* specified radius to remain in the PointCloud. For example if 1 neighbor is specified,
* only the yellow point will be removed from the PointCloud. If 2 neighbors are 
* specified then both the yellow and green points will be removed from the PointCloud.
* @param[in] cloud input point cloud
* @param[in] radius radius in meter
* @param[in] neighbors number of neighbors required
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    radiusOutlineRemoval(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud,
                         float radius, int neighbors);

/**
Remove NaN values from surface normals
* @param[in] cloud input point cloud
*/
    pcl::PointCloud<pcl::PointNormal>::Ptr
    removeNaNNormals(const pcl::PointCloud<pcl::PointNormal>::Ptr &cloud);

/**
Apply Eigen Affine3D Matrix transformation to the point cloud.
* @param[in] cloud input point cloud
* @param[in] axis the axis to rotate the cloud
* @param[in] theta the angle in radians
* @param[in] translation apply translation if needed, otherwise pass zero
* @param[in] centroid boolean value where if true: rotate around centroid if false: rotate around origin
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    matrixTransform(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud,
                    char axis, float theta, float translation, bool centroid);
/**
Apply Median Filter to the point cloud
* @param[in] cloud input point cloud
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    medianFilter(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud) ;
/**
* Smooth Surface Normals using moving least squares algorithm. Returns a pointer to surface normals
* @param[in] cloud input point cloud
*/
    pcl::PointCloud<pcl::PointNormal>::Ptr
    movingLeastSquaresSmooth(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud);
/**
* Upsample the point cloud using least squares algorithm. Make sure to apply voxel
* grid filter first if the cloud is large.
* @param[in] cloud input point cloud
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr movingLeastSquaresUpsample(
            const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud);
/**
* Apply the selected filters to the point cloud. Modify as required.
* @param[in] cloud input point cloud
* @param[in] min_val minimum value to apply the filter
* @param[in] max_val maximum value to apply the filter
* @param[in] leaf_size the size of leaf
* @param[in] radius radius in meters
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    applyFilters(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud,
                 float min_val, float max_val, float leaf_size, float radius,
                 int neighbors);
/**
* Apply bilateral filter to the point cloud. It smoothes the point cloud
* while preserving edges.
* @param[in] cloud input point cloud
*/
    pcl::PointCloud<pcl::PointXYZRGB>::Ptr
    bilateralFilter(const pcl::PointCloud<pcl::PointXYZRGB>::Ptr &cloud) ;

};
