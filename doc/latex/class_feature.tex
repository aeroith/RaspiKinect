\hypertarget{class_feature}{}\section{Feature Class Reference}
\label{class_feature}\index{Feature@{Feature}}


{\ttfamily \#include $<$feature.\+h$>$}

Inheritance diagram for Feature\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_feature}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_feature_1_1my_cloud}{my\+Cloud}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \hyperlink{class_feature_a2160d57e3a1502d84bd87dd3a3b5da9c}{estimate\+Surface\+Normals} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&cloud, float radius)
\item 
pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \hyperlink{class_feature_afadf68008d421f98696ee7e60e4b28a6}{estimate\+Surface\+Normals\+O\+MP} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&cloud, float radius)
\item 
pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \hyperlink{class_feature_a448116b76768ad35cdda20deee99d0d1}{get\+Sift\+Keypoints} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&cloud, const float min\+\_\+scale, const int n\+\_\+octaves, const int n\+\_\+scales\+\_\+per\+\_\+octave, const float min\+\_\+contrast)
\item 
pcl\+::\+Point\+Cloud$<$ pcl\+::\+F\+P\+F\+H\+Signature33 $>$\+::Ptr \hyperlink{class_feature_a89423b19d0d8c4ed67b4b625ddf5422f}{get\+Local\+Descriptor} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&points, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \&normals, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&keypoints, float radius)
\item 
pcl\+::\+Point\+Cloud$<$ pcl\+::\+V\+F\+H\+Signature308 $>$\+::Ptr \hyperlink{class_feature_ab2180a5c65923e5334204be9bf0fbd74}{get\+Global\+Descriptor} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&points, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \&normals)
\item 
boost\+::shared\+\_\+ptr$<$ \hyperlink{struct_feature_1_1my_cloud}{Feature\+::my\+Cloud} $>$ \hyperlink{class_feature_acf2008a37df967514cb04d0598aa1c79}{apply\+Features} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&cloud)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A \hyperlink{class_feature}{Feature} class that holds many useful functions 

\subsection{Member Function Documentation}
\hypertarget{class_feature_acf2008a37df967514cb04d0598aa1c79}{}\label{class_feature_acf2008a37df967514cb04d0598aa1c79} 
\index{Feature@{Feature}!apply\+Features@{apply\+Features}}
\index{apply\+Features@{apply\+Features}!Feature@{Feature}}
\subsubsection{\texorpdfstring{apply\+Features()}{applyFeatures()}}
{\footnotesize\ttfamily boost\+::shared\+\_\+ptr$<$ \hyperlink{struct_feature_1_1my_cloud}{Feature\+::my\+Cloud} $>$ Feature\+::apply\+Features (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{cloud }\end{DoxyParamCaption})}

Apply the feature extraction to the given \hyperlink{struct_feature_1_1my_cloud}{my\+Cloud} struct. Returns a pointer to the \hyperlink{struct_feature_1_1my_cloud}{my\+Cloud} struct. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cloud} & input point cloud \\
\hline
\end{DoxyParams}
\hypertarget{class_feature_a2160d57e3a1502d84bd87dd3a3b5da9c}{}\label{class_feature_a2160d57e3a1502d84bd87dd3a3b5da9c} 
\index{Feature@{Feature}!estimate\+Surface\+Normals@{estimate\+Surface\+Normals}}
\index{estimate\+Surface\+Normals@{estimate\+Surface\+Normals}!Feature@{Feature}}
\subsubsection{\texorpdfstring{estimate\+Surface\+Normals()}{estimateSurfaceNormals()}}
{\footnotesize\ttfamily pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr Feature\+::estimate\+Surface\+Normals (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{cloud,  }\item[{float}]{radius }\end{DoxyParamCaption})}

Estimate Surface Normals using kdtree 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cloud} & input point cloud \\
\hline
\mbox{\tt in}  & {\em radius} & radius in meters \\
\hline
\end{DoxyParams}
\begin{DoxyRefDesc}{Deprecated}
\item[\hyperlink{deprecated__deprecated000001}{Deprecated}]Use estimate\+Surface\+Normals\+O\+MP instead for better performance \end{DoxyRefDesc}
\hypertarget{class_feature_afadf68008d421f98696ee7e60e4b28a6}{}\label{class_feature_afadf68008d421f98696ee7e60e4b28a6} 
\index{Feature@{Feature}!estimate\+Surface\+Normals\+O\+MP@{estimate\+Surface\+Normals\+O\+MP}}
\index{estimate\+Surface\+Normals\+O\+MP@{estimate\+Surface\+Normals\+O\+MP}!Feature@{Feature}}
\subsubsection{\texorpdfstring{estimate\+Surface\+Normals\+O\+M\+P()}{estimateSurfaceNormalsOMP()}}
{\footnotesize\ttfamily pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr Feature\+::estimate\+Surface\+Normals\+O\+MP (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{cloud,  }\item[{float}]{radius }\end{DoxyParamCaption})}

Estimate Surface Normals using kdtree. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cloud} & input point cloud \\
\hline
\mbox{\tt in}  & {\em radius} & radius in meters \\
\hline
\end{DoxyParams}
\hypertarget{class_feature_ab2180a5c65923e5334204be9bf0fbd74}{}\label{class_feature_ab2180a5c65923e5334204be9bf0fbd74} 
\index{Feature@{Feature}!get\+Global\+Descriptor@{get\+Global\+Descriptor}}
\index{get\+Global\+Descriptor@{get\+Global\+Descriptor}!Feature@{Feature}}
\subsubsection{\texorpdfstring{get\+Global\+Descriptor()}{getGlobalDescriptor()}}
{\footnotesize\ttfamily pcl\+::\+Point\+Cloud$<$ pcl\+::\+V\+F\+H\+Signature308 $>$\+::Ptr Feature\+::get\+Global\+Descriptor (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{points,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \&}]{normals }\end{DoxyParamCaption})}

Viewpoint \hyperlink{class_feature}{Feature} Histogram (\mbox{[}V\+FH\mbox{]}) descriptor, a novel representation for point clusters for the problem of Cluster (e.\+g., Object) Recognition and 6\+D\+OF Pose Estimation. Uses a similar approach like Fast Point \hyperlink{class_feature}{Feature} Histogram but much faster. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em points} & input point cloud \\
\hline
\mbox{\tt in}  & {\em normals} & point cloud normals \\
\hline
\end{DoxyParams}
\hypertarget{class_feature_a89423b19d0d8c4ed67b4b625ddf5422f}{}\label{class_feature_a89423b19d0d8c4ed67b4b625ddf5422f} 
\index{Feature@{Feature}!get\+Local\+Descriptor@{get\+Local\+Descriptor}}
\index{get\+Local\+Descriptor@{get\+Local\+Descriptor}!Feature@{Feature}}
\subsubsection{\texorpdfstring{get\+Local\+Descriptor()}{getLocalDescriptor()}}
{\footnotesize\ttfamily pcl\+::\+Point\+Cloud$<$ pcl\+::\+F\+P\+F\+H\+Signature33 $>$\+::Ptr Feature\+::get\+Local\+Descriptor (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{points,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \&}]{normals,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{keypoints,  }\item[{float}]{radius }\end{DoxyParamCaption})}

Compute Fast Point \hyperlink{class_feature}{Feature} Histograms. The default F\+P\+FH implementation uses 11 binning subdivisions (e.\+g., each of the four feature values will use this many bins from its value interval), and a decorrelated scheme which results in a 33-\/byte array of float values. These are stored in a pcl\+::\+F\+P\+F\+H\+Signature33 point type. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em points} & input point cloud \\
\hline
\mbox{\tt in}  & {\em normals} & point cloud normals \\
\hline
\mbox{\tt in}  & {\em keypoints} & computed keypoints \\
\hline
\mbox{\tt in}  & {\em radius} & radius in meters \\
\hline
\end{DoxyParams}
\hypertarget{class_feature_a448116b76768ad35cdda20deee99d0d1}{}\label{class_feature_a448116b76768ad35cdda20deee99d0d1} 
\index{Feature@{Feature}!get\+Sift\+Keypoints@{get\+Sift\+Keypoints}}
\index{get\+Sift\+Keypoints@{get\+Sift\+Keypoints}!Feature@{Feature}}
\subsubsection{\texorpdfstring{get\+Sift\+Keypoints()}{getSiftKeypoints()}}
{\footnotesize\ttfamily pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr Feature\+::get\+Sift\+Keypoints (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{cloud,  }\item[{const float}]{min\+\_\+scale,  }\item[{const int}]{n\+\_\+octaves,  }\item[{const int}]{n\+\_\+scales\+\_\+per\+\_\+octave,  }\item[{const float}]{min\+\_\+contrast }\end{DoxyParamCaption})}

Compute keypoints using a 3D adaptation of David Loweâ€™s S\+I\+FT keypoint detector. Returns a pointer to X\+Y\+Z\+R\+GB Point Cloud. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cloud} & input point cloud \\
\hline
\mbox{\tt in}  & {\em min\+\_\+scale} & the standard deviation of the smallest scale in the scale space \\
\hline
\mbox{\tt in}  & {\em n\+\_\+octaves} & the number of octaves (i.\+e. doublings of scale) to compute \\
\hline
\mbox{\tt in}  & {\em n\+\_\+scales\+\_\+per\+\_\+octave} & the number of scales to compute within each octave \\
\hline
\mbox{\tt in}  & {\em min\+\_\+contrast} & the minimum contrast required for detection \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/serhat/\+Work/\+Kinect/\+Raspi\+Kinect/src/feature.\+h\item 
/home/serhat/\+Work/\+Kinect/\+Raspi\+Kinect/src/feature.\+cpp\end{DoxyCompactItemize}
