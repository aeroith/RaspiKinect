\hypertarget{class_registration}{}\section{Registration Class Reference}
\label{class_registration}\index{Registration@{Registration}}
Inheritance diagram for Registration\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_registration}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
Eigen\+::\+Matrix4f \hyperlink{class_registration_af6438bb515d5f1f24111f8b97384b280}{compute\+Initial\+Alignment} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&source\+\_\+points, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+F\+P\+F\+H\+Signature33 $>$\+::Ptr \&source\+\_\+descriptors, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&target\+\_\+points, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+F\+P\+F\+H\+Signature33 $>$\+::Ptr \&target\+\_\+descriptors, float min\+\_\+sample\+\_\+distance, float max\+\_\+correspondence\+\_\+distance, int nr\+\_\+iterations)
\item 
Eigen\+::\+Matrix4f \hyperlink{class_registration_add23c5ac003e016a3d7b66a7545615c5}{refine\+Alignment} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&source\+\_\+points, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&target\+\_\+points, const Eigen\+::\+Matrix4f \&initial\+\_\+alignment, float max\+\_\+correspondence\+\_\+distance, float outlier\+\_\+rejection\+\_\+threshold, float transformation\+\_\+epsilon, int max\+\_\+iterations)
\item 
pcl\+::\+Polygon\+Mesh \hyperlink{class_registration_aa426fa2e667b8deebae10feaaca2c9ab}{poisson\+Reconstruct} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+YZ $>$\+::Ptr \&cloud, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \&cloud\+\_\+normals)
\item 
pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \hyperlink{class_registration_a3283eaf6aa94fbb2d7e697cd8ce6baef}{apply\+I\+CP} (const boost\+::shared\+\_\+ptr$<$ \hyperlink{struct_feature_1_1my_cloud}{Feature\+::my\+Cloud} $>$ \&Cloud\+\_\+left, const boost\+::shared\+\_\+ptr$<$ \hyperlink{struct_feature_1_1my_cloud}{Feature\+::my\+Cloud} $>$ \&Cloud\+\_\+right)
\item 
pcl\+::\+Polygon\+Mesh \hyperlink{class_registration_a14ea447775824a95cfe3396d304767fe}{greedy\+Triangulation} (const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&cloud, const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \&cloud\+\_\+normals)
\end{DoxyCompactItemize}


\subsection{Member Function Documentation}
\hypertarget{class_registration_a3283eaf6aa94fbb2d7e697cd8ce6baef}{}\label{class_registration_a3283eaf6aa94fbb2d7e697cd8ce6baef} 
\index{Registration@{Registration}!apply\+I\+CP@{apply\+I\+CP}}
\index{apply\+I\+CP@{apply\+I\+CP}!Registration@{Registration}}
\subsubsection{\texorpdfstring{apply\+I\+C\+P()}{applyICP()}}
{\footnotesize\ttfamily pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr Registration\+::apply\+I\+CP (\begin{DoxyParamCaption}\item[{const boost\+::shared\+\_\+ptr$<$ \hyperlink{struct_feature_1_1my_cloud}{Feature\+::my\+Cloud} $>$ \&}]{Cloud\+\_\+left,  }\item[{const boost\+::shared\+\_\+ptr$<$ \hyperlink{struct_feature_1_1my_cloud}{Feature\+::my\+Cloud} $>$ \&}]{Cloud\+\_\+right }\end{DoxyParamCaption})}

Apply I\+CP using the \hyperlink{class_registration_af6438bb515d5f1f24111f8b97384b280}{compute\+Initial\+Alignment()} and \hyperlink{class_registration_add23c5ac003e016a3d7b66a7545615c5}{refine\+Alignment()} functions and obtain combined clouds. Returns left hand side point cloud as a combination of both. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em Cloud\+\_\+left} & left hand side my\+Cloud struct \\
\hline
\mbox{\tt in}  & {\em Cloud\+\_\+right} & right hand side my\+Cloud struct \\
\hline
\end{DoxyParams}
\hypertarget{class_registration_af6438bb515d5f1f24111f8b97384b280}{}\label{class_registration_af6438bb515d5f1f24111f8b97384b280} 
\index{Registration@{Registration}!compute\+Initial\+Alignment@{compute\+Initial\+Alignment}}
\index{compute\+Initial\+Alignment@{compute\+Initial\+Alignment}!Registration@{Registration}}
\subsubsection{\texorpdfstring{compute\+Initial\+Alignment()}{computeInitialAlignment()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix4f Registration\+::compute\+Initial\+Alignment (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{source\+\_\+points,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+F\+P\+F\+H\+Signature33 $>$\+::Ptr \&}]{source\+\_\+descriptors,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{target\+\_\+points,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+F\+P\+F\+H\+Signature33 $>$\+::Ptr \&}]{target\+\_\+descriptors,  }\item[{float}]{min\+\_\+sample\+\_\+distance,  }\item[{float}]{max\+\_\+correspondence\+\_\+distance,  }\item[{int}]{nr\+\_\+iterations }\end{DoxyParamCaption})}

Use Sample\+Consensus\+Initial\+Alignment to find a rough alignment from the source cloud to the target cloud by finding correspondences between two sets of local features 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em source\+\_\+points} & The \char`\"{}source\char`\"{} points, i.\+e., the points that must be transformed to align with the target point cloud \\
\hline
\mbox{\tt in}  & {\em source\+\_\+descriptors} & The local descriptors for each source point \\
\hline
\mbox{\tt in}  & {\em target\+\_\+points} & The \char`\"{}target\char`\"{} points, i.\+e., the points to which the source point cloud will be aligned \\
\hline
\mbox{\tt in}  & {\em target\+\_\+descriptors} & The local descriptors for each target point \\
\hline
\mbox{\tt in}  & {\em min\+\_\+sample\+\_\+distance} & The minimum distance between any two random samples \\
\hline
\mbox{\tt in}  & {\em max\+\_\+correspondence\+\_\+distance} & The \\
\hline
\mbox{\tt in}  & {\em nr\+\_\+iterations} & The number of R\+A\+N\+S\+AC iterations to perform Return\+: A transformation matrix that will roughly align the points in source to the points in target \\
\hline
\end{DoxyParams}
\hypertarget{class_registration_a14ea447775824a95cfe3396d304767fe}{}\label{class_registration_a14ea447775824a95cfe3396d304767fe} 
\index{Registration@{Registration}!greedy\+Triangulation@{greedy\+Triangulation}}
\index{greedy\+Triangulation@{greedy\+Triangulation}!Registration@{Registration}}
\subsubsection{\texorpdfstring{greedy\+Triangulation()}{greedyTriangulation()}}
{\footnotesize\ttfamily pcl\+::\+Polygon\+Mesh Registration\+::greedy\+Triangulation (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{cloud,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \&}]{cloud\+\_\+normals }\end{DoxyParamCaption})}

Apply a greedy surface triangulation algorithm on a Point\+Cloud with normals, to obtain a triangle mesh based on projections of the local neighborhoods. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cloud} & input point cloud \\
\hline
\mbox{\tt in}  & {\em cloud\+\_\+normals} & point cloud normals \\
\hline
\end{DoxyParams}
\hypertarget{class_registration_aa426fa2e667b8deebae10feaaca2c9ab}{}\label{class_registration_aa426fa2e667b8deebae10feaaca2c9ab} 
\index{Registration@{Registration}!poisson\+Reconstruct@{poisson\+Reconstruct}}
\index{poisson\+Reconstruct@{poisson\+Reconstruct}!Registration@{Registration}}
\subsubsection{\texorpdfstring{poisson\+Reconstruct()}{poissonReconstruct()}}
{\footnotesize\ttfamily pcl\+::\+Polygon\+Mesh Registration\+::poisson\+Reconstruct (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+YZ $>$\+::Ptr \&}]{cloud,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Normal $>$\+::Ptr \&}]{cloud\+\_\+normals }\end{DoxyParamCaption})}

Apply poisson reconstruction to the point clouds. Does not yield very good results for kinect output. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cloud} & input point cloud \\
\hline
\mbox{\tt out}  & {\em cloud\+\_\+normals} & point cloud normals \\
\hline
\end{DoxyParams}
\hypertarget{class_registration_add23c5ac003e016a3d7b66a7545615c5}{}\label{class_registration_add23c5ac003e016a3d7b66a7545615c5} 
\index{Registration@{Registration}!refine\+Alignment@{refine\+Alignment}}
\index{refine\+Alignment@{refine\+Alignment}!Registration@{Registration}}
\subsubsection{\texorpdfstring{refine\+Alignment()}{refineAlignment()}}
{\footnotesize\ttfamily Eigen\+::\+Matrix4f Registration\+::refine\+Alignment (\begin{DoxyParamCaption}\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{source\+\_\+points,  }\item[{const pcl\+::\+Point\+Cloud$<$ pcl\+::\+Point\+X\+Y\+Z\+R\+GB $>$\+::Ptr \&}]{target\+\_\+points,  }\item[{const Eigen\+::\+Matrix4f \&}]{initial\+\_\+alignment,  }\item[{float}]{max\+\_\+correspondence\+\_\+distance,  }\item[{float}]{outlier\+\_\+rejection\+\_\+threshold,  }\item[{float}]{transformation\+\_\+epsilon,  }\item[{int}]{max\+\_\+iterations }\end{DoxyParamCaption})}

Use Iterative\+Closest\+Point to find a precise alignment from the source cloud to the target cloud, starting with an intial guess 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em source\+\_\+points} & The \char`\"{}source\char`\"{} points, i.\+e., the points that must be transformed to align with the target point cloud \\
\hline
\mbox{\tt in}  & {\em target\+\_\+points} & The \char`\"{}target\char`\"{} points, i.\+e., the points to which the source point cloud will be aligned \\
\hline
\mbox{\tt in}  & {\em initial\+\_\+alignment} & An initial estimate of the transformation matrix that aligns the source points to the target points \\
\hline
\mbox{\tt in}  & {\em max\+\_\+correspondence\+\_\+distance} & A threshold on the distance between any two corresponding points. Any corresponding points that are further apart than this threshold will be ignored when computing the source-\/to-\/target transformation \\
\hline
\mbox{\tt in}  & {\em outlier\+\_\+rejection\+\_\+threshold} & A threshold used to define outliers during R\+A\+N\+S\+AC outlier rejection \\
\hline
\mbox{\tt in}  & {\em transformation\+\_\+epsilon} & The smallest iterative transformation allowed before the algorithm is considered to have converged \\
\hline
\mbox{\tt in}  & {\em max\+\_\+iterations} & The maximum number of I\+CP iterations to perform Return\+: A transformation matrix that will precisely align the points in source to the points in target \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/serhat/\+Work/\+Kinect/\+Raspi\+Kinect/src/registration.\+h\item 
/home/serhat/\+Work/\+Kinect/\+Raspi\+Kinect/src/registration.\+cpp\end{DoxyCompactItemize}
